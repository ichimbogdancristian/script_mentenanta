#Requires -Version 7.0

<#
.SYNOPSIS
    System Inventory Module - Type 1 (Inventory/Reporting)

.DESCRIPTION
    Collects comprehensive system information including hardware, software,
    services, and configuration details for maintenance analysis and reporting.

.NOTES
    Module Type: Type 1 (Inventory/Reporting)
    Dependencies: Windows WMI/CIM, Registry access
    Author: Windows Maintenance Automation Project
    Version: 1.0.0
#>

using namespace System.Collections.Generic

# Import required modules
$ModuleRoot = Split-Path -Parent $PSScriptRoot
$FileOrgPath = Join-Path $ModuleRoot 'core\FileOrganizationManager.psm1'
if (Test-Path $FileOrgPath) {
    Import-Module $FileOrgPath -Force
}

#region Public Functions

<#
.SYNOPSIS
    Collects comprehensive system inventory information

.DESCRIPTION
    Gathers detailed system information including hardware specs, installed software,
    running services, network configuration, and security settings.

.PARAMETER UseCache
    Use cached results if available and not expired

.PARAMETER CacheTimeout
    Cache timeout in minutes (default: 30)

.PARAMETER IncludeDetailed
    Include detailed information that may take longer to collect

.EXAMPLE
    $inventory = Get-SystemInventory -IncludeDetailed
#>
function Get-SystemInventory {
    [CmdletBinding()]
    param(
        [Parameter()]
        [switch]$UseCache,

        [Parameter()]
        [int]$CacheTimeout = 30,

        [Parameter()]
        [switch]$IncludeDetailed
    )

    Write-Information "üîç Starting system inventory collection..." -InformationAction Continue

    # Check for cached inventory data if UseCache is enabled
    if ($UseCache) {
        $scriptRoot = Split-Path -Parent (Split-Path -Parent (Split-Path -Parent $PSScriptRoot))
        $inventoryDir = Join-Path $scriptRoot 'temp_files\inventory'

        if (Test-Path $inventoryDir) {
            # Find the most recent inventory file
            $recentInventory = Get-ChildItem -Path $inventoryDir -Filter "system-inventory-*.json" |
                               Sort-Object LastWriteTime -Descending |
                               Select-Object -First 1

            if ($recentInventory) {
                $cacheAge = (Get-Date) - $recentInventory.LastWriteTime
                if ($cacheAge.TotalMinutes -le $CacheTimeout) {
                    try {
                        Write-Information "  üóÇÔ∏è  Using cached inventory data (age: $([math]::Round($cacheAge.TotalMinutes, 1)) minutes)" -InformationAction Continue
                        $cachedData = Get-Content -Path $recentInventory.FullName -Raw | ConvertFrom-Json -AsHashtable
                        return $cachedData
                    }
                    catch {
                        Write-Warning "Failed to load cached inventory data: $_. Collecting fresh data."
                    }
                }
                else {
                    Write-Warning "  ‚è∞ Cached inventory data expired (age: $([math]::Round($cacheAge.TotalMinutes, 1)) minutes > $CacheTimeout minutes)"
                }
            }
        }
    }

    $startTime = Get-Date
    $inventoryData = @{}

    try {
        # Basic system information
        Write-Information "  üìä Collecting basic system information..." -InformationAction Continue
        $inventoryData.SystemInfo = Get-BasicSystemInfo

        # Hardware information
        Write-Information "  üñ•Ô∏è Collecting hardware information..." -InformationAction Continue
        $inventoryData.Hardware = Get-HardwareInfo

        # Operating system details
        Write-Information "  üíª Collecting operating system details..." -InformationAction Continue
        $inventoryData.OperatingSystem = Get-OperatingSystemInfo

        # Installed software
        Write-Information "  üì¶ Collecting installed software..." -InformationAction Continue
        $inventoryData.InstalledSoftware = Get-InstalledSoftwareInfo

        # Running services
        Write-Information "  üîß Collecting services information..." -InformationAction Continue
        $inventoryData.Services = Get-ServicesInfo

        # Network configuration
        Write-Information "  üåê Collecting network configuration..." -InformationAction Continue
        $inventoryData.Network = Get-NetworkInfo

        if ($IncludeDetailed) {
            # Detailed information (slower to collect)
            Write-Information "  üîé Collecting detailed information..." -InformationAction Continue
            $inventoryData.DetailedInfo = Get-DetailedSystemInfo
        }

        # Add metadata
        $inventoryData.Metadata = @{
            CollectionTime = $startTime
            Duration = ((Get-Date) - $startTime).TotalSeconds
            IncludeDetailed = $IncludeDetailed.IsPresent
            ComputerName = $env:COMPUTERNAME
            UserName = $env:USERNAME
            ModuleVersion = '1.0.0'
        }

        $duration = [math]::Round($inventoryData.Metadata.Duration, 2)
        Write-Information "  ‚úÖ System inventory completed in $duration seconds" -InformationAction Continue

        # Auto-save inventory data using organized file system
        try {
            # Save main inventory data
            $inventoryPath = Save-OrganizedFile -Data $inventoryData -FileType 'Data' -Category 'inventory' -FileName 'system-inventory' -Format 'JSON'
            if ($inventoryPath) {
                Write-Information "  üíæ System inventory saved to: $inventoryPath" -InformationAction Continue
            }

            # Also save installed software as a separate list for easier comparison
            $installedSoftwarePath = Save-OrganizedFile -Data $inventoryData.InstalledSoftware -FileType 'Data' -Category 'inventory' -FileName 'installed-software' -Format 'JSON'
            if ($installedSoftwarePath) {
                Write-Information "  üì¶ Installed software list saved to: $installedSoftwarePath" -InformationAction Continue
            }
        }
        catch {
            Write-Warning "Failed to save inventory data: $_"
        }

        return $inventoryData
    }
    catch {
        Write-Error "Failed to collect system inventory: $_"
        throw
    }
}

<#
.SYNOPSIS
    Exports system inventory to various formats

.DESCRIPTION
    Saves the system inventory data to JSON, XML, or CSV formats for reporting and analysis.

.PARAMETER InventoryData
    The inventory data object to export

.PARAMETER OutputPath
    Base path for output files (without extension)

.PARAMETER Format
    Export format(s): JSON, XML, CSV, or All

.EXAMPLE
    Export-SystemInventory -InventoryData $inventory -OutputPath "C:\Reports\SystemInventory" -Format All
#>
function Export-SystemInventory {
    [CmdletBinding(SupportsShouldProcess)]
    param(
        [Parameter(Mandatory)]
        [hashtable]$InventoryData,

        [Parameter(Mandatory)]
        [string]$OutputPath,

        [Parameter()]
        [ValidateSet('JSON', 'XML', 'CSV', 'All')]
        [string]$Format = 'JSON'
    )

    $baseDir = Split-Path $OutputPath -Parent
    if (-not (Test-Path $baseDir)) {
        New-Item -Path $baseDir -ItemType Directory -Force | Out-Null
    }

    $exports = @()

    if ($Format -eq 'All' -or $Format -eq 'JSON') {
        $jsonPath = "$OutputPath.json"
        if ($PSCmdlet.ShouldProcess($jsonPath, "Export to JSON")) {
            $InventoryData | ConvertTo-Json -Depth 10 | Out-File -FilePath $jsonPath -Encoding UTF8
            $exports += $jsonPath
            Write-Verbose "Exported to JSON: $jsonPath"
        }
    }

    if ($Format -eq 'All' -or $Format -eq 'XML') {
        $xmlPath = "$OutputPath.xml"
        if ($PSCmdlet.ShouldProcess($xmlPath, "Export to XML")) {
            $InventoryData | Export-Clixml -Path $xmlPath -Depth 10
            $exports += $xmlPath
            Write-Verbose "Exported to XML: $xmlPath"
        }
    }

    if ($Format -eq 'All' -or $Format -eq 'CSV') {
        $csvDir = "$OutputPath-CSV"
        if ($PSCmdlet.ShouldProcess($csvDir, "Export to CSV")) {
            if (-not (Test-Path $csvDir)) {
                New-Item -Path $csvDir -ItemType Directory -Force | Out-Null
            }

            # Export each section to separate CSV files
            foreach ($section in $InventoryData.Keys) {
                if ($section -ne 'Metadata' -and $InventoryData[$section] -is [Array]) {
                    $csvPath = Join-Path $csvDir "$section.csv"
                    $InventoryData[$section] | Export-Csv -Path $csvPath -NoTypeInformation
                    $exports += $csvPath
                }
            }
            Write-Verbose "Exported to CSV directory: $csvDir"
        }
    }

    return $exports
}

#endregion

#region Private Functions

<#
.SYNOPSIS
    Collects basic system information
#>
function Get-BasicSystemInfo {
    try {
        $computerSystem = Get-CimInstance -ClassName Win32_ComputerSystem -ErrorAction Stop
        $bios = Get-CimInstance -ClassName Win32_BIOS -ErrorAction Stop

        return @{
            ComputerName = $computerSystem.Name
            Domain = $computerSystem.Domain
            Manufacturer = $computerSystem.Manufacturer
            Model = $computerSystem.Model
            TotalPhysicalMemory = $computerSystem.TotalPhysicalMemory
            NumberOfProcessors = $computerSystem.NumberOfProcessors
            BIOSVersion = $bios.SMBIOSBIOSVersion
            BIOSManufacturer = $bios.Manufacturer
            SerialNumber = $bios.SerialNumber
        }
    }
    catch {
        Write-Warning "Failed to collect basic system info: $_"
        return @{}
    }
}

<#
.SYNOPSIS
    Collects hardware information
#>
function Get-HardwareInfo {
    try {
        $processor = Get-CimInstance -ClassName Win32_Processor -ErrorAction Stop | Select-Object -First 1
        $memory = Get-CimInstance -ClassName Win32_PhysicalMemory -ErrorAction Stop
        $diskDrives = Get-CimInstance -ClassName Win32_DiskDrive -ErrorAction Stop
        $videoController = Get-CimInstance -ClassName Win32_VideoController -ErrorAction Stop |
                          Where-Object { $_.Name -notlike "*Basic*" } | Select-Object -First 1

        return @{
            Processor = @{
                Name = $processor.Name
                Architecture = $processor.Architecture
                NumberOfCores = $processor.NumberOfCores
                NumberOfLogicalProcessors = $processor.NumberOfLogicalProcessors
                MaxClockSpeed = $processor.MaxClockSpeed
            }
            Memory = @{
                TotalModules = $memory.Count
                TotalCapacity = ($memory | Measure-Object Capacity -Sum).Sum
                Modules = $memory | ForEach-Object {
                    @{
                        Capacity = $_.Capacity
                        Speed = $_.Speed
                        Manufacturer = $_.Manufacturer
                        PartNumber = $_.PartNumber
                    }
                }
            }
            Storage = $diskDrives | ForEach-Object {
                @{
                    Model = $_.Model
                    Size = $_.Size
                    InterfaceType = $_.InterfaceType
                    MediaType = $_.MediaType
                }
            }
            Graphics = if ($videoController) {
                @{
                    Name = $videoController.Name
                    DriverVersion = $videoController.DriverVersion
                    DriverDate = $videoController.DriverDate
                    AdapterRAM = $videoController.AdapterRAM
                }
            } else { $null }
        }
    }
    catch {
        Write-Warning "Failed to collect hardware info: $_"
        return @{}
    }
}

<#
.SYNOPSIS
    Collects operating system information
#>
function Get-OperatingSystemInfo {
    try {
        $os = Get-CimInstance -ClassName Win32_OperatingSystem -ErrorAction Stop
        $timeZone = Get-TimeZone -ErrorAction Stop

        return @{
            Caption = $os.Caption
            Version = $os.Version
            BuildNumber = $os.BuildNumber
            Architecture = $os.OSArchitecture
            InstallDate = $os.InstallDate
            LastBootUpTime = $os.LastBootUpTime
            FreePhysicalMemory = $os.FreePhysicalMemory
            TotalVirtualMemorySize = $os.TotalVirtualMemorySize
            TimeZone = $timeZone.DisplayName
            PowerShellVersion = $PSVersionTable.PSVersion.ToString()
            DotNetVersion = [System.Environment]::Version.ToString()
        }
    }
    catch {
        Write-Warning "Failed to collect OS info: $_"
        return @{}
    }
}

<#
.SYNOPSIS
    Collects installed software information
#>
function Get-InstalledSoftwareInfo {
    try {
        $installedPrograms = @()

        # Get AppX packages
        try {
            $appxPackages = Get-AppxPackage -ErrorAction SilentlyContinue | Where-Object { $_.Name -notlike "*Microsoft*" -or $_.Name -like "*Microsoft.Office*" }
            foreach ($package in $appxPackages) {
                $installedPrograms += @{
                    Name = $package.Name
                    DisplayName = $package.PackageFullName
                    Version = $package.Version
                    Publisher = $package.Publisher
                    InstallLocation = $package.InstallLocation
                    Source = 'AppX'
                }
            }
        }
        catch {
            Write-Verbose "Failed to collect AppX packages: $_"
        }

        # Get Winget packages
        try {
            $wingetOutput = winget list --accept-source-agreements 2>$null
            if ($wingetOutput) {
                $wingetLines = $wingetOutput | Select-Object -Skip 2 | Where-Object { $_ -and $_ -notmatch "^-+" }
                foreach ($line in $wingetLines) {
                    if ($line -match '^(.+?)\s+(.+?)\s+(.+?)\s+(.+?)$') {
                        $installedPrograms += @{
                            Name = $matches[1].Trim()
                            Version = $matches[2].Trim()
                            Publisher = $matches[4].Trim()
                            Source = 'Winget'
                        }
                    }
                }
            }
        }
        catch {
            Write-Verbose "Failed to collect Winget packages: $_"
        }

        # Get Chocolatey packages
        try {
            if (Get-Command choco -ErrorAction SilentlyContinue) {
                $chocoOutput = choco list --local-only --no-progress 2>$null
                foreach ($line in $chocoOutput) {
                    if ($line -match '^(.+?)\s+(.+?)$') {
                        $installedPrograms += @{
                            Name = $matches[1].Trim()
                            Version = $matches[2].Trim()
                            Publisher = 'Chocolatey'
                            Source = 'Chocolatey'
                        }
                    }
                }
            }
        }
        catch {
            Write-Verbose "Failed to collect Chocolatey packages: $_"
        }

        # Get programs from registry (both 32-bit and 64-bit)
        $registryPaths = @(
            'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\*',
            'HKLM:\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*'
        )

        foreach ($path in $registryPaths) {
            $programs = Get-ItemProperty $path -ErrorAction SilentlyContinue |
                       Where-Object { $_.DisplayName -and $_.DisplayName -notmatch '^KB[0-9]+' }

            foreach ($program in $programs) {
                $installedPrograms += @{
                    Name = $program.DisplayName
                    DisplayName = $program.DisplayName
                    Version = $program.DisplayVersion
                    Publisher = $program.Publisher
                    InstallDate = $program.InstallDate
                    InstallLocation = $program.InstallLocation
                    UninstallString = $program.UninstallString
                    Size = $program.EstimatedSize
                    Source = 'Registry'
                }
            }
        }

        return @{
            TotalCount = $installedPrograms.Count
            Programs = $installedPrograms | Sort-Object Name
        }
    }
    catch {
        Write-Warning "Failed to collect installed software info: $_"
        return @{ TotalCount = 0; Programs = @() }
    }
}

<#
.SYNOPSIS
    Collects services information
#>
function Get-ServicesInfo {
    try {
        # Use WMI/CIM first as it has better permission handling than Get-Service
        try {
            Write-Verbose "Querying services using CIM (WMI) for better permission handling"
            $wmiServices = Get-CimInstance -ClassName Win32_Service -ErrorAction Stop
            $services = $wmiServices | ForEach-Object {
                [PSCustomObject]@{
                    Name = $_.Name
                    DisplayName = $_.DisplayName
                    Status = if ($_.State -eq 'Running') { 'Running' } else { 'Stopped' }
                    StartType = $_.StartMode
                }
            }
        }
        catch {
            Write-Verbose "CIM approach failed, trying selective Get-Service: $_"
            # Fallback to Get-Service but with error handling for individual services
            $services = @()
            $allServiceNames = (Get-Service -ErrorAction SilentlyContinue).Name

            foreach ($serviceName in $allServiceNames) {
                try {
                    $service = Get-Service -Name $serviceName -ErrorAction Stop
                    $services += [PSCustomObject]@{
                        Name = $service.Name
                        DisplayName = $service.DisplayName
                        Status = $service.Status
                        StartType = $service.StartType
                    }
                }
                catch {
                    # Skip services that can't be queried (like WaaSMedicSvc)
                    Write-Verbose "Skipping service '$serviceName' due to permission restriction"
                    continue
                }
            }
        }

        if ($services.Count -eq 0) {
            Write-Warning "No services could be queried. This may indicate permission restrictions."
            return @{
                TotalCount = 0
                RunningCount = 0
                StoppedCount = 0
                RunningServices = @()
                CriticalServices = @()
                Note = "Limited permissions - service details unavailable"
            }
        }

        $runningServices = $services | Where-Object { $_.Status -eq 'Running' }
        $stoppedServices = $services | Where-Object { $_.Status -eq 'Stopped' }

        return @{
            TotalCount = $services.Count
            RunningCount = $runningServices.Count
            StoppedCount = $stoppedServices.Count
            RunningServices = $runningServices | ForEach-Object {
                @{
                    Name = $_.Name
                    DisplayName = $_.DisplayName
                    Status = $_.Status
                    StartType = $_.StartType
                }
            }
            CriticalServices = $runningServices | Where-Object {
                $_.Name -in @('Winlogon', 'CSRSS', 'Wininit', 'Services', 'Lsass', 'Spooler')
            } | ForEach-Object {
                @{
                    Name = $_.Name
                    DisplayName = $_.DisplayName
                    Status = $_.Status
                }
            }
        }
    }
    catch {
        Write-Warning "Failed to collect services info: $_"
        return @{
            TotalCount = 0
            RunningCount = 0
            StoppedCount = 0
            RunningServices = @()
            CriticalServices = @()
            Error = $_.Exception.Message
        }
    }
}

<#
.SYNOPSIS
    Collects network configuration information
#>
function Get-NetworkInfo {
    try {
        $adapters = Get-NetAdapter -Physical -ErrorAction Stop | Where-Object { $_.Status -eq 'Up' }
        $ipConfig = Get-NetIPConfiguration -ErrorAction Stop | Where-Object { $_.NetAdapter.Status -eq 'Up' }

        return @{
            Adapters = $adapters | ForEach-Object {
                $config = $ipConfig | Where-Object { $_.InterfaceAlias -eq $_.Name }
                @{
                    Name = $_.Name
                    Description = $_.InterfaceDescription
                    LinkSpeed = $_.LinkSpeed
                    MediaType = $_.MediaType
                    MacAddress = $_.MacAddress
                    IPAddress = $config.IPv4Address.IPAddress -join ', '
                    SubnetMask = $config.IPv4Address.PrefixLength -join ', '
                    DefaultGateway = $config.IPv4DefaultGateway.NextHop -join ', '
                    DNSServers = $config.DNSServer.ServerAddresses -join ', '
                }
            }
            InternetConnectivity = Test-InternetConnectivity
        }
    }
    catch {
        Write-Warning "Failed to collect network info: $_"
        return @{}
    }
}

<#
.SYNOPSIS
    Collects detailed system information (slower operations)
#>
function Get-DetailedSystemInfo {
    try {
        return @{
            InstalledUpdates = Get-InstalledUpdatesInfo
            StartupPrograms = Get-StartupProgramsInfo
            ScheduledTasks = Get-ScheduledTasksInfo
            EventLogSummary = Get-EventLogSummary
        }
    }
    catch {
        Write-Warning "Failed to collect detailed info: $_"
        return @{}
    }
}

<#
.SYNOPSIS
    Gets installed Windows updates information
#>
function Get-InstalledUpdatesInfo {
    try {
        $updates = Get-CimInstance -ClassName Win32_QuickFixEngineering -ErrorAction Stop |
                   Sort-Object InstalledOn -Descending |
                   Select-Object -First 20

        return @{
            RecentCount = $updates.Count
            RecentUpdates = $updates | ForEach-Object {
                @{
                    HotFixID = $_.HotFixID
                    Description = $_.Description
                    InstalledOn = $_.InstalledOn
                    InstalledBy = $_.InstalledBy
                }
            }
        }
    }
    catch {
        Write-Warning "Failed to get updates info: $_"
        return @{}
    }
}

<#
.SYNOPSIS
    Gets startup programs information
#>
function Get-StartupProgramsInfo {
    try {
        $startupItems = @()

        # Registry startup locations
        $startupPaths = @(
            'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Run',
            'HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion\Run',
            'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce',
            'HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce'
        )

        foreach ($path in $startupPaths) {
            try {
                $items = Get-ItemProperty $path -ErrorAction SilentlyContinue
                if ($items) {
                    foreach ($property in $items.PSObject.Properties) {
                        if ($property.Name -notin @('PSPath', 'PSParentPath', 'PSChildName', 'PSDrive', 'PSProvider')) {
                            $startupItems += @{
                                Name = $property.Name
                                Command = $property.Value
                                Location = $path
                            }
                        }
                    }
                }
            }
            catch {
                # Skip inaccessible registry paths
            }
        }

        return @{
            TotalCount = $startupItems.Count
            Items = $startupItems
        }
    }
    catch {
        Write-Warning "Failed to get startup programs: $_"
        return @{}
    }
}

<#
.SYNOPSIS
    Gets scheduled tasks summary
#>
function Get-ScheduledTasksInfo {
    try {
        $tasks = Get-ScheduledTask -ErrorAction Stop
        $runningTasks = $tasks | Where-Object { $_.State -eq 'Running' }
        $enabledTasks = $tasks | Where-Object { $_.State -eq 'Ready' }

        return @{
            TotalCount = $tasks.Count
            RunningCount = $runningTasks.Count
            EnabledCount = $enabledTasks.Count
            RunningTasks = $runningTasks | Select-Object -First 10 | ForEach-Object {
                @{
                    TaskName = $_.TaskName
                    TaskPath = $_.TaskPath
                    State = $_.State
                }
            }
        }
    }
    catch {
        Write-Warning "Failed to get scheduled tasks: $_"
        return @{}
    }
}

<#
.SYNOPSIS
    Gets event log summary
#>
function Get-EventLogSummary {
    try {
        $logs = @('System', 'Application', 'Security')
        $summary = @{}

        foreach ($logName in $logs) {
            try {
                $events = Get-WinEvent -LogName $logName -MaxEvents 1000 -ErrorAction Stop
                $errors = $events | Where-Object { $_.LevelDisplayName -eq 'Error' }
                $warnings = $events | Where-Object { $_.LevelDisplayName -eq 'Warning' }

                $summary[$logName] = @{
                    TotalEvents = $events.Count
                    ErrorCount = $errors.Count
                    WarningCount = $warnings.Count
                    RecentErrors = $errors | Select-Object -First 5 | ForEach-Object {
                        @{
                            TimeCreated = $_.TimeCreated
                            Id = $_.Id
                            LevelDisplayName = $_.LevelDisplayName
                            Message = $_.Message.Substring(0, [Math]::Min(200, $_.Message.Length))
                        }
                    }
                }
            }
            catch {
                $summary[$logName] = @{ Error = "Access denied or log not available" }
            }
        }

        return $summary
    }
    catch {
        Write-Warning "Failed to get event log summary: $_"
        return @{}
    }
}

<#
.SYNOPSIS
    Tests internet connectivity
#>
function Test-InternetConnectivity {
    try {
        $testSites = @('8.8.8.8', 'google.com', 'microsoft.com')
        $results = @{}

        foreach ($site in $testSites) {
            try {
                $result = Test-Connection -ComputerName $site -Count 1 -Quiet -TimeoutSeconds 5
                $results[$site] = $result
            }
            catch {
                $results[$site] = $false
            }
        }

        return $results
    }
    catch {
        return @{ Error = "Connectivity test failed" }
    }
}

#endregion

# Export module functions
Export-ModuleMember -Function @(
    'Get-SystemInventory',
    'Export-SystemInventory'
)
